function [DICconcinit, d13CDICinit, pHinit, GWmodel, CO2lost, DICconcmodel, d13CDICmodel, pHmodel, volumemodel] = degassingInverseModel(DICconc, d13CDIC, pH, Temperature, d13CDICinit, Q)
%% Inverse model for CO2 degassing from streams (Venkiteswaran et al. submitted to PLoS ONE)
% Model takes the forward degassing model and wraps it with fminsearch and
% bounds and tries to find a solution for the initial conditions that lead
% to the measured DIC and d13CDIC values.

% inputs: DICconc, d13CDIC, pH, Temperature, d13CDICinit
%       but d13CDICinit is assumed to be -26‰
%
% output: DICconcinit, d13CDICinit, CO2lost, pHinit
%       but d13CDICinit is assumed to be -26‰

% bounds
%       DIC < DICinit < DICmax?
%       pHmin < pHinit < pH
%       ? < d13CDICinit < d13CDIC < ?
% fminsearch
%     call degassingModel(DICconcinit, d13CDICinit, pHinit, Temperature, varargin)
%     with initial conditions (randomized from within the bounds)
%     pH_from_Alk gets called automatically at each timestep
%     return DIC and d13CDIC with time from the degassingModel
%     calculate error via some interpolation of model output d13CDIC values as the diff detween DICmodel(interp) and DICfield
% return error to fminsearch to minimise it
% 
% output variables (DICconcinit, d13CDICinit, CO2lost, pHinit)
% 
% figures


%% Set up bounds and Starting variable based on diel_input
% add a 10% buffer to DIC and pH to avoid problems of the sse turing out NaN
bounds.DICconcinit = [DICconc*1.01 3000]; % shallow groundwater can't be above 3000umol/L ?
bounds.pHinit = [4 0.99*pH]; % shallow groundwater can't be below pH4 ?
bounds.d13CDICinit = [d13CDICinit-0.001 d13CDICinit+0.001]; % since we want to force it to be -26‰
bounds.GW = [0 1e-2]; % likely to be close to 1e-4

% First, find a random number for each variable within the bounds
% Option 1 is with random values within bounds
% p.DICconcinit = bounds.DICconcinit(1) + rand .* (bounds.DICconcinit(2) - bounds.DICconcinit(1));
% p.pHinit = bounds.pHinit(1) + rand .* (bounds.pHinit(2) - bounds.pHinit(1));
% p.d13CDICinit = bounds.d13CDICinit(1) + rand .* (bounds.d13CDICinit(2) - bounds.d13CDICinit(1));
% p.GW = bounds.GW(1) + rand .* (bounds.GW(2) - bounds.GW(1));
% Option 2 is try forcing reasonable starting points to avoid too many errors during model runs
p.DICconcinit = 1401;
p.pHinit = 5;
p.d13CDICinit = -26;
p.GW = 1e-5;

% Second, transform the p and then assign to Starting because fminsearch
% takes a matrix (Starting) and not a struct (p and p_trans)
[p_trans] = transform(p, bounds);
Starting = [p_trans.DICconcinit p_trans.pHinit p_trans.d13CDICinit p_trans.GW];


%% call fminsearch
% Define function and starting point of fitting routine.
fun = @expfun;

% Set up the options for fminsearch
% [x,fval,exitflag,output] = fminsearch(fun,x0,options)
% options = optimset('fminsearch');   % Use FMINSEARCH defaults
options = optimset('FunValCheck', 'on');
% [Estimates, FVAL, EXITFLAG, OPTIONS] = fminsearch(fun, Starting, [], bounds); % no options to speed up
[Estimates, FVAL, EXITFLAG, OPTIONS] = fminsearch(fun, Starting, options, bounds);

disp(Estimates);
disp(FVAL);
disp(EXITFLAG);
disp(OPTIONS);

% Return these values: [DICconcinit, d13CDICinit, pHinit, CO2lost]
p_trans.DICconcinit = Estimates(1);
p_trans.pHinit = Estimates(2);
p_trans.d13CDICinit = Estimates(3);
p_trans.GW = Estimates(4);
[p] = detransform(p_trans, bounds);

DICconcinit = p.DICconcinit;
d13CDICinit = p.d13CDICinit;
pHinit = p.pHinit;
GW = p.GW;
CO2lost = DICconcinit-DICconc; % this needs to be fixed to be all the CO2 lost at each time-step and therefore would have to be exported from the model istelf (turns out it is practically the same as CO2lost)


%% check the fit generated by fminsearch and make figures
% To check the fit visually, rerun the model with the "last" set of Estimates
% This is essentially:

% Switch "last" set of Estimates back to the struct p_trans before passing
% to detransform.
p_trans.DICconcinit = Estimates(1);
p_trans.pHinit = Estimates(2);
p_trans.d13CDICinit = Estimates(3);
p_trans.GW = Estimates(4);
[p] = detransform(p_trans, bounds);

% Go through the degassingModel and generate model data based on some input params.
% [DICconc, d13CDIC, gemass, CO2conc, d13CCO2, pH, Alkconc, volume, geiso] = ...
%     degassingModel(DICconcinit, d13CDICinit, pHinit, Temperature, varargin)
%     varargin = GW, k, runlength
[DICconcmodel, d13CDICmodel] = degassingModel(DICconcinit, d13CDICinit, pHinit, Temperature, GW);
GWmodel = GW; % variable for export

% Figures here
% figure;
% ax = subplot(3,1,1);
% hold all;
% h1 = plot(d13CDICmodel, DICconcmodel, 'b-', 'linewidth', 2);
% h2 = scatter(d13CDIC, DICconc, 'ro', 'markerfacecolor', [1 0 0]);
% %xlabel('\delta^{13}C-DIC ({\fontsize{12}%}{\fontsize{8}o})');
% ylabel('DIC (\mumol/L)');
% grid on;
% ax = subplot(3,1,2);
% hold all;
% h1 = plot(d13CDICmodel, DICconcmodel(1)-DICconcmodel, 'b-', 'linewidth', 2);
% h2 = scatter(d13CDIC, DICconcmodel(1)-DICconc, 'ro', 'markerfacecolor', [1 0 0]);
% %xlabel('\delta^{13}C-DIC ({\fontsize{12}%}{\fontsize{8}o})');
% ylabel('\DeltaDIC (\mumol/L)');
% grid on;
% ax = subplot(3,1,3);
% hold all;
% h1 = plot(d13CDICmodel, pHmodel, 'b-', 'linewidth', 2);
% h2 = scatter(d13CDIC, pH, 'ro', 'markerfacecolor', [1 0 0]);
% xlabel('\delta^{13}C-DIC ({\fontsize{12}%}{\fontsize{8}o})');
% ylabel('pH');
% grid on;


%% Export data and model results

% no code written yet
% wrapper function simply exports the init variables and
% variables with time


%%  the fun expfun
% ---------- all calculations inside the fminsearch "loop" (expfun) are below ----------
function [sse] = expfun(params, bounds)

% fminsearch will always use transformed variables so we can always
% detransform them here BEFORE passing them to the model.
% fminsearch starts with params and we pass that to detransform
% Switch params back to the struct p_trans before passing to detransform
p_trans.DICconcinit = params(1);
p_trans.pHinit = params(2);
p_trans.d13CDICinit = params(3);
p_trans.GW = params(4);
[p] = detransform(p_trans, bounds);
DICconcinit = p.DICconcinit;
pHinit = p.pHinit;
d13CDICinit = p.d13CDICinit;
GW = p.GW;

% Go through the degassingModel and generate model data based on some input params.
% [DICconc, d13CDIC, gemass, CO2conc, d13CCO2, pH, Alkconc, volume, geiso] = ...
%     degassingModel(DICconcinit, d13CDICinit, pHinit, Temperature, varargin)
%     varargin = GW, k, runlength
[DICconcmodel, d13CDICmodel, ~, ~, ~, pHmodel, ~, volumemodel] = degassingModel(DICconcinit, d13CDICinit, pHinit, Temperature, GW);
% Noting that volumemodel is really Q since it's L and timestep is s

% Calculate error based on interpolating the d13CDIC values from the model
% output to get a match with the field data; then figure out the DIC from
% the model and the difference between that modelled DIC and field DIC is
% the error we want to return.
% What happens if there is a NaN in here? Use the extrapval option of interp1
% disp('here');
% disp(params);
% disp(DICconc - interp1(d13CDICmodel, DICconcmodel, d13CDIC,'linear'));

disp(['Unique: ', num2str(length(unique(DICconcmodel))), '  ', ...
    num2str(length(unique(d13CDICmodel))), '   ', ...
    'Init: ', num2str([DICconcinit pHinit GW])]);

% Multiplying by 100 to give a larger number to see if this helps
% fminsearch get our of NaN-based ruts
sse = (((DICconc - interp1(d13CDICmodel, DICconcmodel, d13CDIC, 'linear', 1))/DICconc).^2 + ...
    ((pH - interp1(d13CDICmodel, pHmodel, d13CDIC, 'linear', 1))/pH).^2 + ...
    ((Q - interp1(d13CDICmodel, volumemodel, d13CDIC, 'linear', 1))/Q).^2)*100;

% Shouldn't ever have to do this
if isnan(sse) == 1
    sse = 100;
end

disp(['SSE: ', num2str(sse), ...
    ' Diff DIC: ', num2str(DICconc - interp1(d13CDICmodel, DICconcmodel, d13CDIC,'linear')), ...
    ' Diff pH: ', num2str(pH - interp1(d13CDICmodel, pHmodel, d13CDIC,'linear')), ...
    ' Diff Q: ', num2str(Q - interp1(d13CDICmodel, volumemodel, d13CDIC,'linear'))]);

% ---------- all calculations inside the fminsearch "loop" (expfun) are above ----------
end


%% transform function
function [p_trans] = transform(p, bounds)
% Inverse sine to transform the values.

% Use a sine transformation e.g. p.P = asin(p_trans.P) + b has minimum value of (b-a)
% and maximum value of (b+a), so if the prescribed bounds are bmax and bmin
% then a and b are a=(bmax-bmin)/2 and b=(bmax+bmin)/2 .
a = (bounds.DICconcinit(2) - bounds.DICconcinit(1))/2;
b = (bounds.DICconcinit(2) + bounds.DICconcinit(1))/2;
p_trans.DICconcinit  = asin((p.DICconcinit-b)/a);
a = (bounds.pHinit(2) - bounds.pHinit(1))/2;
b = (bounds.pHinit(2) + bounds.pHinit(1))/2;
p_trans.pHinit  = asin((p.pHinit-b)/a);
a = (bounds.d13CDICinit(2) - bounds.d13CDICinit(1))/2;
b = (bounds.d13CDICinit(2) + bounds.d13CDICinit(1))/2;
p_trans.d13CDICinit  = asin((p.d13CDICinit-b)/a);
a = (bounds.GW(2) - bounds.GW(1))/2;
b = (bounds.GW(2) + bounds.GW(1))/2;
p_trans.GW  = asin((p.GW-b)/a);
end


%% detransform function
function [p] = detransform(p_trans, bounds)
% Sine to detransform the values.

% Use a sine transformation e.g. p.DICconcinit = asin(p_trans.DICconcinit) + b has minimum value of (b-a)
% and maximum value of (b+a), so if the prescribed bounds are bmax and bmin
% then a and b are a=(bmax-bmin)/2 and b=(bmax+bmin)/2 .
a = (bounds.DICconcinit(2) - bounds.DICconcinit(1))/2;
b = (bounds.DICconcinit(2) + bounds.DICconcinit(1))/2;
p.DICconcinit = a * sin(p_trans.DICconcinit) + b;
a = (bounds.pHinit(2) - bounds.pHinit(1))/2;
b = (bounds.pHinit(2) + bounds.pHinit(1))/2;
p.pHinit = a * sin(p_trans.pHinit) + b;
a = (bounds.d13CDICinit(2) - bounds.d13CDICinit(1))/2;
b = (bounds.d13CDICinit(2) + bounds.d13CDICinit(1))/2;
p.d13CDICinit = a * sin(p_trans.d13CDICinit) + b;
a = (bounds.GW(2) - bounds.GW(1))/2;
b = (bounds.GW(2) + bounds.GW(1))/2;
p.GW = a * sin(p_trans.GW) + b;
end

end
%EOF
